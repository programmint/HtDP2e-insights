学习笔记 / 第5章：添加结构体

<br>

### 5.10、r3 与 R3 区别？

<br>

P105

```
(define-struct r3 [x y z])
; An R3 is a structure:
;   (make-r3 Number Number Number)
 
(define ex1 (make-r3 1 2 13))
(define ex2 (make-r3 -1 0 3))
```

令人备感奇怪，定义了结构体 r3，可是注释却写成了 R3，字母大小写之间有什么差别？

<br>

问了 Ai (deepseek + gemini)，答复如下：

<br>

**第 1、结构体名称 (r3，小写）**

**语法定义** ：(define-struct r3 [x y z])

这是结构体类型的构造函数名称，遵循 Racket 的命名惯例（通常小写+短横线分隔）。

**用途：** 用于创建具体的结构体实例，例如：

~~~
(make-r3 1 2 3)  ; 构造一个 r3 实例
(r3? some-value) ; 检查是否为 r3 结构体
(r3-x a-point)   ; 访问字段 x
~~~

**本质：** 这是代码中实际操作的“工具名”，与语法直接绑定。

<br>

**第 2. 数据定义名称 (R3，大写）**   

**数据定义注释：**
~~~
; An R3 is a structure:
;   (make-r3 Number Number Number)
~~~
这是程序员为一类数据所起的名字，**它遵循 HtDP 的一个统一命名约定：TitleCase（每个单词首字母大写）。这个约定适用于所有类型的数据定义，而不仅仅是结构体。**

为什么是 R3 而不是 R3D? R3 是一个数学上的通用缩写，本身就是一个专有名词，所以直接使用。

~~~
R3代表什么？

"3-dimensional Real number space" 或者简称为 "Real 3D"。

按照 TitleCase 规则，应该是 Real3D。

但 R3 是一个非常通用的数学缩写，它本身就是一个专有名词。
在这种情况下，使用广为接受的缩写 R3 是更清晰的选择。因为 "R" 和 "3" 都可以被看作是这个概念的独立部分，所以它们都保持了大写。这恰好是一个特殊但又常见的例子。
~~~

更通用的例子： 当我们定义一个“虚拟猫 (Virtual Cat)”时，数据定义名就是 VCat；定义“交通灯 (TrafficLight)”时，就是 TrafficLight。

- VCat (Virtual Cat): (define-struct vcat ...)

- TrafficLight (Traffic Light): (define-struct traffic-light ...)
- VAnimal (Virtual Animal): 这是一个混合类型，不是结构体，但因为它也是一个数据定义，所以同样遵循 TitleCase 规则。

这个约定的核心目的：

**统一性与可识别性：** 
只要在代码注释或函数签名里看到一个 TitleCase 的名字，我们立刻知道这是一个需要查找其定义的数据类型。

**避免混淆：**
- TitleCase (e.g., VCat) -> 数据定义
- lowercase (e.g., vcat) -> Racket 的结构体类型名
- ALL_CAPS (e.g., WIDTH) -> 全局常量 这三者有了清晰的视觉区分，代码可读性大大增强。

**抽象层级：** 
R3, VCat 这些名字代表的是逻辑上的概念（“三维点”、“一只虚拟猫”），而 r3, vcat 是操作这些概念的代码工具。


<br>

**为什么不能统一用小写？**  

**技术必要性：**

Racket 语法要求结构体构造函数（如 make-r3）和类型检查（如 r3?）必须用小写命名，这是语言规范。

数据定义（如 R3）是程序员自定义的注释名称，不受语法限制，但需遵循可读性约定。

<br>

**设计意图：**

**区分抽象与实现：**

**r3**（小写）是具体的结构体操作（代码实现）。

**R3**（大写）是抽象的数据类型（设计文档）。

**避免混淆：**

例如，当看到 R3 时，程序员知道它代表逻辑上的“三维点”概念；而 r3 是操作这个概念的语法工具。

<br>

**HTDP 的设计哲学**

HTDP 强调数据定义与代码实现的分离：

**第 1、数据定义**（如 R3）描述“合法数据是什么”。

**第 2、结构体定义**（如 r3）描述“如何构造和操作数据”。

这种分离让程序更易理解和维护。例如，若未来需要扩展 R3（如增加约束条件），只需修改数据定义，而不必重写结构体代码。



